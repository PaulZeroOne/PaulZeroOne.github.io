<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”Œ</text></svg>">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Portfolio â€” AP</title>
<style>
  /* =====================================================================
     GLOBAL STYLES
     ===================================================================== */
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;400;600;700&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --tp1: #00ffff;
    --tp2: #ff00ff;
    --tp3: #00ff66;
    --tp4: #ff8800;
    --bg: #060a0f;
    --panel: #0c1219;
    --panel2: #101820;
    --border: rgba(255,255,255,0.06);
    --text: #cdd6e0;
    --text-dim: #6a7d8e;
    --font-mono: 'Share Tech Mono', monospace;
    --font-ui: 'Rajdhani', sans-serif;
  }

  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: var(--bg);
    font-family: var(--font-ui);
    color: var(--text);
  }

  canvas { display: block; }

  /* =====================================================================
     HEADER HUD
     ===================================================================== */
  #hud {
    position: fixed; top: 0; left: 0; right: 0;
    display: flex; align-items: center; justify-content: space-between;
    padding: 18px 32px;
    background: linear-gradient(to bottom, rgba(6,10,15,0.95) 60%, transparent);
    z-index: 10;
    pointer-events: none;
  }

  #hud-left {
    display: flex; flex-direction: column;
  }

  #hud-name {
    font-family: var(--font-ui);
    font-size: 22px;
    font-weight: 700;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: #e8edf2;
  }

  #hud-title {
    font-family: var(--font-mono);
    font-size: 11px;
    color: var(--text-dim);
    letter-spacing: 0.2em;
    margin-top: 3px;
  }

  #hud-right {
    font-family: var(--font-mono);
    font-size: 10px;
    color: var(--text-dim);
    text-align: right;
    line-height: 1.8;
  }

  .hud-indicator {
    display: inline-block;
    width: 6px; height: 6px;
    border-radius: 50%;
    background: var(--tp3);
    box-shadow: 0 0 6px var(--tp3);
    margin-right: 6px;
    animation: pulse 2s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* =====================================================================
     BOTTOM STATUS BAR
     ===================================================================== */
  #statusbar {
    position: fixed; bottom: 0; left: 0; right: 0;
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 32px;
    background: linear-gradient(to top, rgba(6,10,15,0.95) 60%, transparent);
    font-family: var(--font-mono);
    font-size: 10px;
    color: var(--text-dim);
    z-index: 10;
    pointer-events: none;
  }

  #statusbar .tp-nav {
    display: flex; gap: 28px;
  }

  .tp-tag {
    display: flex; align-items: center; gap: 6px;
  }

  .tp-dot {
    width: 7px; height: 7px;
    border-radius: 50%;
    border: 1.5px solid;
  }

  /* =====================================================================
     TOOLTIP
     ===================================================================== */
  #tooltip {
    position: fixed;
    padding: 7px 14px;
    background: rgba(12,18,25,0.95);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 4px;
    font-family: var(--font-mono);
    font-size: 11px;
    color: #e0e8f0;
    pointer-events: none;
    opacity: 0;
    transform: translateY(4px);
    transition: opacity 0.18s ease, transform 0.18s ease;
    z-index: 50;
    white-space: nowrap;
  }

  #tooltip.visible {
    opacity: 1;
    transform: translateY(0);
  }

  #tooltip-label {
    font-weight: 600;
    margin-bottom: 2px;
    letter-spacing: 0.05em;
  }

  #tooltip-hint {
    font-size: 9px;
    color: var(--text-dim);
    letter-spacing: 0.08em;
  }

  /* =====================================================================
     MODAL OVERLAY
     ===================================================================== */
  #modal-overlay {
    position: fixed; inset: 0;
    background: rgba(4,8,12,0.82);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    z-index: 100;
    display: flex; align-items: center; justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  #modal-overlay.open {
    opacity: 1;
    pointer-events: all;
  }

  #modal {
    width: min(720px, 94vw);
    max-height: 82vh;
    background: var(--panel);
    border-radius: 10px;
    border: 1px solid var(--border);
    display: flex; flex-direction: column;
    overflow: hidden;
    transform: translateY(20px) scale(0.97);
    transition: transform 0.3s cubic-bezier(0.16,1,0.3,1);
    box-shadow: 0 32px 80px rgba(0,0,0,0.6), 0 0 0 1px rgba(255,255,255,0.04);
    position: relative;
  }

  #modal-overlay.open #modal {
    transform: translateY(0) scale(1);
  }

  /* Colored top border accent, set via JS */
  #modal::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
    background: var(--modal-accent, #00ffff);
    box-shadow: 0 0 16px var(--modal-accent, #00ffff);
    z-index: 1;
  }

  #modal-header {
    padding: 22px 28px 16px;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: flex-start; justify-content: space-between;
    flex-shrink: 0;
    background: var(--panel);
  }

  #modal-tp-badge {
    font-family: var(--font-mono);
    font-size: 10px;
    letter-spacing: 0.2em;
    color: var(--modal-accent, #00ffff);
    text-shadow: 0 0 8px var(--modal-accent, #00ffff);
    margin-bottom: 6px;
  }

  #modal-title {
    font-family: var(--font-ui);
    font-size: 26px;
    font-weight: 700;
    letter-spacing: 0.04em;
    color: #e8edf2;
  }

  #modal-close {
    width: 34px; height: 34px;
    border-radius: 50%;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text-dim);
    font-size: 18px;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.18s;
    flex-shrink: 0;
    margin-left: 16px;
    margin-top: 4px;
    font-family: var(--font-mono);
  }

  #modal-close:hover {
    background: rgba(255,255,255,0.06);
    color: #e8edf2;
    border-color: rgba(255,255,255,0.16);
  }

  #modal-body {
    padding: 28px;
    overflow-y: auto;
    flex: 1;
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,0.1) transparent;
  }

  #modal-body::-webkit-scrollbar { width: 4px; }
  #modal-body::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 2px; }

  /* =====================================================================
     MODAL CONTENT COMPONENTS
     ===================================================================== */
  .section-label {
    font-family: var(--font-mono);
    font-size: 9px;
    letter-spacing: 0.25em;
    color: var(--text-dim);
    text-transform: uppercase;
    margin-bottom: 14px;
    display: flex; align-items: center; gap: 10px;
  }

  .section-label::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  .bio-text {
    font-size: 15px;
    line-height: 1.75;
    color: var(--text);
    margin-bottom: 24px;
    font-weight: 400;
  }

  .skill-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
    gap: 8px;
    margin-bottom: 28px;
  }

  .skill-tag {
    padding: 7px 12px;
    background: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    font-family: var(--font-mono);
    font-size: 11px;
    color: var(--text-dim);
    text-align: center;
    letter-spacing: 0.05em;
  }

  .card-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 14px;
    margin-bottom: 24px;
  }

  @media (max-width: 500px) { .card-grid { grid-template-columns: 1fr; } }

  .project-card {
    background: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 18px;
    transition: border-color 0.2s;
  }

  .project-card:hover {
    border-color: rgba(255,255,255,0.12);
  }

  .project-card-tag {
    font-family: var(--font-mono);
    font-size: 9px;
    letter-spacing: 0.2em;
    color: var(--modal-accent, #00ffff);
    margin-bottom: 8px;
  }

  .project-card-title {
    font-size: 15px;
    font-weight: 700;
    letter-spacing: 0.03em;
    color: #e0e8f2;
    margin-bottom: 8px;
  }

  .project-card-desc {
    font-size: 12px;
    line-height: 1.6;
    color: var(--text-dim);
  }

  .timeline {
    display: flex; flex-direction: column; gap: 0;
    margin-bottom: 24px;
  }

  .timeline-item {
    display: grid;
    grid-template-columns: 90px 1fr;
    gap: 20px;
    padding: 18px 0;
    border-bottom: 1px solid var(--border);
    position: relative;
  }

  .timeline-item:last-child { border-bottom: none; }

  .timeline-date {
    font-family: var(--font-mono);
    font-size: 10px;
    color: var(--text-dim);
    letter-spacing: 0.08em;
    padding-top: 3px;
  }

  .timeline-role {
    font-size: 15px;
    font-weight: 700;
    color: #dde6ee;
    letter-spacing: 0.03em;
    margin-bottom: 4px;
  }

  .timeline-company {
    font-family: var(--font-mono);
    font-size: 11px;
    color: var(--modal-accent, #00ffff);
    margin-bottom: 8px;
    text-shadow: 0 0 6px var(--modal-accent, #00ffff);
  }

  .timeline-desc {
    font-size: 12px;
    line-height: 1.65;
    color: var(--text-dim);
  }

  /* Student group cards */
.group-card {
  background: var(--panel2);
  border: 1px solid var(--border);
  border-left: 3px solid var(--modal-accent, #ff8800);
  border-radius: 8px;
  padding: 14px 16px;
  margin-bottom: 10px;
  transition: border-color 0.2s;
}
.group-card:hover { border-color: var(--modal-accent, #ff8800); }
.group-card-name {
  font-size: 14px; font-weight: 700; color: #dde6ee; margin-bottom: 4px;
}
.group-card-role {
  font-family: var(--font-mono); font-size: 10px;
  color: var(--modal-accent, #ff8800); letter-spacing: 0.08em; margin-bottom: 6px;
}
.group-card-desc {
  font-size: 12px; color: var(--text-dim); line-height: 1.5;
}

/* Contact icon links */
.contact-icons {
  display: flex; gap: 12px; margin-top: 12px; flex-wrap: wrap;
}
.contact-link {
  display: flex; align-items: center; gap: 8px;
  padding: 10px 16px;
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text-dim);
  text-decoration: none;
  font-family: var(--font-mono);
  font-size: 11px;
  letter-spacing: 0.06em;
  transition: border-color 0.2s, color 0.2s;
}
.contact-link:hover {
  border-color: var(--modal-accent, #ff8800);
  color: var(--modal-accent, #ff8800);
}
.contact-link svg {
  width: 16px; height: 16px; flex-shrink: 0;
  fill: currentColor;
}

  /* =====================================================================
     LOADING OVERLAY
     ===================================================================== */
  #loading {
    position: fixed; inset: 0;
    background: var(--bg);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 200;
    transition: opacity 0.6s ease;
  }

  #loading.hidden { opacity: 0; pointer-events: none; }

  .load-pcb-icon {
    width: 60px; height: 60px;
    border: 2px solid rgba(0,255,102,0.2);
    border-top-color: var(--tp3);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .load-text {
    font-family: var(--font-mono);
    font-size: 11px;
    letter-spacing: 0.3em;
    color: var(--text-dim);
  }
</style>
</head>
<body>

<!-- ===== HUD HEADER ===== -->
<div id="hud">
  <div id="hud-left">
    <!-- CUSTOMIZE: Your name and title -->
    <div id="hud-name">Abhronil Paul</div>
    <div id="hud-title">// HARDWARE_ENGINEER &amp; AVIONICS_SYSTEMS_ARCHITECT</div>
  </div>
  <div id="hud-right">
    <span class="hud-indicator"></span>BOARD_REV_0.1<br>
    PCB-PORTFOLIO.BRD<br>
  </div>
</div>

<!-- ===== BOTTOM STATUS BAR ===== -->
<div id="statusbar">
  <div>LEFT-DRAG: ORBIT &nbsp;Â·&nbsp; MIDDLE-DRAG: PAN &nbsp;Â·&nbsp; SCROLL: ZOOM</div>
  <div class="tp-nav">
    <!-- CUSTOMIZE: Test point labels -->
    <div class="tp-tag"><div class="tp-dot" style="border-color:#00ffff;box-shadow:0 0 5px #00ffff"></div>TP1 Â· ABOUT</div>
    <div class="tp-tag"><div class="tp-dot" style="border-color:#ff00ff;box-shadow:0 0 5px #ff00ff"></div>TP2 Â· PROJECTS</div>
    <div class="tp-tag"><div class="tp-dot" style="border-color:#00ff66;box-shadow:0 0 5px #00ff66"></div>TP3 Â· EXPERIENCE</div>
    <div class="tp-tag"><div class="tp-dot" style="border-color:#ff8800;box-shadow:0 0 5px #ff8800"></div>TP4 Â· COLLABS</div>
  </div>
</div>

<!-- ===== TOOLTIP ===== -->
<div id="tooltip">
  <div id="tooltip-label"></div>
  <div id="tooltip-hint">CLICK TO OPEN</div>
</div>

<!-- ===== LOADING SCREEN ===== -->
<div id="loading">
  <div class="load-pcb-icon"></div>
  <div class="load-text">INITIALIZING BOARD...</div>
</div>

<!-- ===== MODAL ===== -->
<div id="modal-overlay">
  <div id="modal">
    <div id="modal-header">
      <div>
        <div id="modal-tp-badge">TP1 Â· TEST POINT</div>
        <div id="modal-title">Section Title</div>
      </div>
      <button id="modal-close">âœ•</button>
    </div>
    <div id="modal-body" id="modal-content"></div>
  </div>
</div>

<!-- Three.js + OrbitControls CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* =====================================================================
   PCB PORTFOLIO â€” MAIN SCRIPT
   
   CUSTOMIZATION GUIDE:
   - Test point labels:   Search "CUSTOMIZE: TP labels"
   - Glow colors:         Search "CUSTOMIZE: TP colors"
   - Modal content:       Search "CUSTOMIZE: Modal content"
   - Trace density:       Adjust TRACE_CONFIG object
   - Board dimensions:    Adjust BOARD object
   ===================================================================== */

'use strict';

/* =====================================================================
   CONFIGURATION
   ===================================================================== */
const BOARD = {
  w: 9,
  h: 6,
  depth: 0.14,
  radius: 0.28,
};

// CUSTOMIZE: TP colors & positions â€” scattered across board interior
const TP_CONFIG = [
  { id: 'TP1', label: 'TP1  ABOUT',       color: 0x00ffff, cssColor: '#00ffff', pos: [-2.8, -1.4], section: 'about'      },
  { id: 'TP2', label: 'TP2  PROJECTS',    color: 0xff00ff, cssColor: '#ff00ff', pos: [ 2.6,  0.6], section: 'projects'   },
  { id: 'TP3', label: 'TP3  EXPERIENCE',  color: 0x00ff66, cssColor: '#00ff66', pos: [-0.4,  1.8], section: 'experience' },
  { id: 'TP4', label: 'TP4  COLLABS',     color: 0xff8800, cssColor: '#ff8800', pos: [ 3.0, -2.0], section: 'collabs'    },
];

const TRACE_CONFIG = {
  count: 55,
  minLength: 0.3,
  maxLength: 2.4,
  width: 0.030,   // realistic thin trace â€” about 0.2mm equivalent
  height: 0.015,  // just proud enough to catch specular highlights
};

/* =====================================================================
   SCENE SETUP
   ===================================================================== */
let renderer, scene, camera, controls;
let clock, raycaster;
// Initialize mouse here so the mousemove listener below works before initScene()
const mouse = new THREE.Vector2(-999, -999);
let testPointMeshes = [];      // { mesh, config, glowSprite, traceMeshes }
let hoveredTP = null;
let idleRotating = true;
let animFrameId;

function initScene() {
  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.insertBefore(renderer.domElement, document.body.firstChild);

  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x060a0f);
  scene.fog = new THREE.FogExp2(0x060a0f, 0.045);

  // Camera
  camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(6, 5, 9);
  camera.lookAt(0, 0, 0);

  // Controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.065;
  controls.minDistance = 3;
  controls.maxDistance = 22;
  controls.maxPolarAngle = Math.PI * 0.82;
  controls.mouseButtons = {
    LEFT: THREE.MOUSE.ROTATE,
    MIDDLE: THREE.MOUSE.PAN,
    RIGHT: THREE.MOUSE.PAN,
  };

  controls.addEventListener('start', () => { idleRotating = false; });
  controls.addEventListener('end',   () => { setTimeout(() => { idleRotating = true; }, 3000); });

  // Utilities
  clock    = new THREE.Clock();
  raycaster = new THREE.Raycaster();
}

/* =====================================================================
   LIGHTING
   ===================================================================== */
function initLighting() {
  // Ambient â€” cool dark fill
  const ambient = new THREE.AmbientLight(0x1a2535, 0.9);
  scene.add(ambient);

  // Key light â€” warm from top-right-front
  const key = new THREE.DirectionalLight(0xfff0e0, 1.4);
  key.position.set(6, 10, 6);
  key.castShadow = true;
  key.shadow.mapSize.set(2048, 2048);
  key.shadow.camera.near = 0.5;
  key.shadow.camera.far = 30;
  key.shadow.camera.left = -8;
  key.shadow.camera.right = 8;
  key.shadow.camera.top = 8;
  key.shadow.camera.bottom = -8;
  key.shadow.bias = -0.0003;
  key.shadow.radius = 2;
  scene.add(key);

  // Fill â€” cool blue from left
  const fill = new THREE.DirectionalLight(0xb0d0ff, 0.45);
  fill.position.set(-8, 3, 2);
  scene.add(fill);

  // Rim â€” from behind
  const rim = new THREE.DirectionalLight(0xffffff, 0.25);
  rim.position.set(0, -2, -8);
  scene.add(rim);

  // Subtle ground bounce
  const bounce = new THREE.PointLight(0x203040, 0.6, 20);
  bounce.position.set(0, -4, 0);
  scene.add(bounce);
}

/* =====================================================================
   MATERIALS
   ===================================================================== */
let matSolderMask, matCopperPad, matSilkscreen, matFR4Edge, matVia;

function initMaterials() {
  // PCB solder mask â€” dark green gloss with subtle clearcoat
  matSolderMask = new THREE.MeshPhysicalMaterial({
    color: 0x0b2e18,
    roughness: 0.28,
    metalness: 0.0,
    clearcoat: 0.6,
    clearcoatRoughness: 0.25,
    envMapIntensity: 0.8,
  });

  // Copper â€” warm gold metallic
  matCopperPad = new THREE.MeshStandardMaterial({
    color: 0xc07a28,
    roughness: 0.22,
    metalness: 0.92,
  });

  // Silkscreen â€” matte cream-white
  matSilkscreen = new THREE.MeshStandardMaterial({
    color: 0xd8ddd2,
    roughness: 0.9,
    metalness: 0.0,
  });

  // FR4 edge â€” slightly lighter than mask
  matFR4Edge = new THREE.MeshPhysicalMaterial({
    color: 0x1a3a22,
    roughness: 0.55,
    metalness: 0.0,
  });

  // Via / through-hole â€” bright copper
  matVia = new THREE.MeshStandardMaterial({
    color: 0xb87333,
    roughness: 0.18,
    metalness: 0.95,
  });
}

/* =====================================================================
   BOARD GEOMETRY
   ===================================================================== */
function roundedRectShape(w, h, r) {
  const s = new THREE.Shape();
  s.moveTo(-w/2 + r, -h/2);
  s.lineTo( w/2 - r, -h/2);
  s.quadraticCurveTo( w/2, -h/2,  w/2, -h/2 + r);
  s.lineTo( w/2,  h/2 - r);
  s.quadraticCurveTo( w/2,  h/2,  w/2 - r,  h/2);
  s.lineTo(-w/2 + r,  h/2);
  s.quadraticCurveTo(-w/2,  h/2, -w/2,  h/2 - r);
  s.lineTo(-w/2, -h/2 + r);
  s.quadraticCurveTo(-w/2, -h/2, -w/2 + r, -h/2);
  return s;
}

// Mounting hole positions (in board local XZ = shape XY space)
const MOUNT_HOLES = [
  [-BOARD.w/2 + 0.4, -BOARD.h/2 + 0.4],
  [ BOARD.w/2 - 0.4, -BOARD.h/2 + 0.4],
  [-BOARD.w/2 + 0.4,  BOARD.h/2 - 0.4],
  [ BOARD.w/2 - 0.4,  BOARD.h/2 - 0.4],
];
const MOUNT_HOLE_R = 0.115;

function createBoard() {
  const group = new THREE.Group();
  const { w, h, depth, radius } = BOARD;

  // Build PCB shape with 4 circular holes punched out
  const shape = roundedRectShape(w, h, radius);

  MOUNT_HOLES.forEach(([hx, hy]) => {
    const holePath = new THREE.Path();
    holePath.absarc(hx, hy, MOUNT_HOLE_R, 0, Math.PI * 2, true); // true = CW = hole
    shape.holes.push(holePath);
  });

  const extrudeSettings = {
    steps: 1,
    depth: depth,
    bevelEnabled: false,   // no bevel â€” keeps hole edges crisp
  };
  const pcbGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  pcbGeo.center();

  const pcbMesh = new THREE.Mesh(pcbGeo, [matSolderMask, matFR4Edge]);
  pcbMesh.rotation.x = -Math.PI / 2;
  pcbMesh.castShadow = true;
  pcbMesh.receiveShadow = true;
  group.add(pcbMesh);

  // Copper annular rings + barrel interiors on top of the real holes
  const annW   = 0.075;
  const yFaceTop = depth / 2;
  const yFaceBot = -depth / 2;

  MOUNT_HOLES.forEach(([hx, hy]) => {
    // In world space the board is rotated so shape-Xâ†’world-X, shape-Yâ†’world-Z
    const wx = hx, wz = hy;

    // Copper annular ring â€” flat RingGeometry, top face
    const ringGeo = new THREE.RingGeometry(MOUNT_HOLE_R, MOUNT_HOLE_R + annW, 48);
    const ringMat = new THREE.MeshStandardMaterial({
      color: 0xb87333, roughness: 0.18, metalness: 0.95,
    });
    const ringTop = new THREE.Mesh(ringGeo, ringMat);
    ringTop.rotation.x = -Math.PI / 2;
    ringTop.position.set(wx, yFaceTop + 0.001, wz);
    group.add(ringTop);

    // Bottom copper ring
    const ringBot = new THREE.Mesh(ringGeo.clone(), ringMat.clone());
    ringBot.rotation.x = Math.PI / 2;
    ringBot.position.set(wx, yFaceBot - 0.001, wz);
    group.add(ringBot);

    // FR4 barrel interior â€” shows the board cross-section color inside the hole
    const barrelGeo = new THREE.CylinderGeometry(
      MOUNT_HOLE_R, MOUNT_HOLE_R, depth, 48, 1, true
    );
    const barrelMat = new THREE.MeshStandardMaterial({
      color: 0x1a3a22, roughness: 0.8, metalness: 0,
      side: THREE.BackSide,
    });
    const barrel = new THREE.Mesh(barrelGeo, barrelMat);
    barrel.position.set(wx, 0, wz);
    group.add(barrel);

    // Silkscreen circle outline
    const skGeo = new THREE.RingGeometry(
      MOUNT_HOLE_R + annW + 0.008,
      MOUNT_HOLE_R + annW + 0.022, 48
    );
    const skMat = new THREE.MeshBasicMaterial({ color: 0xd0d8c0, side: THREE.DoubleSide });
    const sk = new THREE.Mesh(skGeo, skMat);
    sk.rotation.x = -Math.PI / 2;
    sk.position.set(wx, yFaceTop + 0.002, wz);
    group.add(sk);
  });

  // Board edge outline silkscreen
  addBoardOutline(group, w, h, radius, depth);

  return group;
}

function addBoardOutline(group, w, h, r, depth) {
  // Simple line along top face edges for PCB outline silkscreen
  const points = [];
  const segs = 16;
  const corners = [
    [ w/2 - r,  h/2 - r, r, 0,          Math.PI/2],
    [-w/2 + r,  h/2 - r, r, Math.PI/2,  Math.PI],
    [-w/2 + r, -h/2 + r, r, Math.PI,    3*Math.PI/2],
    [ w/2 - r, -h/2 + r, r, 3*Math.PI/2, 2*Math.PI],
  ];
  corners.forEach(([cx, cz, cr, aStart, aEnd]) => {
    for (let i = 0; i <= segs; i++) {
      const a = aStart + (aEnd - aStart) * i / segs;
      points.push(new THREE.Vector3(cx + Math.cos(a) * cr, depth/2 + 0.004, cz + Math.sin(a) * cr));
    }
  });
  points.push(points[0].clone());
  const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
  const lineMat = new THREE.LineBasicMaterial({ color: 0xddddcc, transparent: true, opacity: 0.5 });
  const line = new THREE.Line(lineGeo, lineMat);
  group.add(line);
}

/* =====================================================================
   SHARED PAD REGISTRY â€” components register pads here, traces read them
   ===================================================================== */
// pads[net] = [[x,z], [x,z], ...]  â€” all pads on the same electrical net
const pads = {};
function regPad(net, x, z) {
  if (!pads[net]) pads[net] = [];
  pads[net].push([x, z]);
  return [x, z];
}

/* =====================================================================
   SMD COMPONENTS  (each helper also registers pad coords)
   ===================================================================== */
function createComponents() {
  const group = new THREE.Group();
  const Y = BOARD.depth / 2;   // board top-face Y

  const pinMat   = new THREE.MeshStandardMaterial({ color:0xa0a0a0, roughness:0.25, metalness:0.85 });
  const blackMat = new THREE.MeshStandardMaterial({ color:0x151515, roughness:0.55, metalness:0.1 });

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function box(w,h,d, mat, x,y,z, ry=0) {
    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
    m.position.set(x,y,z); m.rotation.y=ry; m.castShadow=true;
    group.add(m); return m;
  }

  // 0402 resistor/cap â€” net1 is left pad, net2 is right pad
  let _gndIdx = 0;
  function r0402(x, z, ry, net1, net2, bodyCol=0x2a1a0a) {
    const bMat = new THREE.MeshStandardMaterial({color:bodyCol,roughness:0.75,metalness:0});
    box(0.18,0.055,0.10, bMat, x, Y+0.028, z, ry);
    const p1x = x - Math.cos(ry)*0.09, p1z = z + Math.sin(ry)*0.09;
    const p2x = x + Math.cos(ry)*0.09, p2z = z - Math.sin(ry)*0.09;
    box(0.022,0.055,0.10, pinMat, p1x, Y+0.028, p1z, ry);
    box(0.022,0.055,0.10, pinMat, p2x, Y+0.028, p2z, ry);
    // net2 'gnd' gets a unique sub-net so it connects only to nearest comp pad
    const n2 = (net2==='gnd') ? `gnd_${_gndIdx++}` : net2;
    if (net1) regPad(net1, p1x, p1z);
    if (net2) regPad(n2, p2x, p2z);
  }

  // MLCC cap (tan body, same footprint as 0402 resistor)
  function c0402(x, z, ry, net1, net2) {
    r0402(x, z, ry, net1, net2, 0xc8aa70);
  }

  // Electrolytic cap â€” single GND pad at base center
  function elecCap(x, z, h, r, col, netPos, netNeg) {
    const mat = new THREE.MeshStandardMaterial({color:col,roughness:0.45,metalness:0.2});
    const body = new THREE.Mesh(new THREE.CylinderGeometry(r,r,h,18), mat);
    body.position.set(x, Y+h/2, z); body.castShadow=true; group.add(body);
    const top = new THREE.Mesh(new THREE.CircleGeometry(r,18),
      new THREE.MeshStandardMaterial({color:0x888888,roughness:0.35,metalness:0.75}));
    top.rotation.x=-Math.PI/2; top.position.set(x,Y+h+0.001,z); group.add(top);
    if (netPos) regPad(netPos, x+r*0.4, z);
    if (netNeg) regPad(netNeg, x-r*0.4, z);
  }

  // SOIC-8: 4 pins per side, pitch 0.20, span Â±0.30 from center
  function soic8(x, z, ry, nets) {
    // nets = [L0,L1,L2,L3, R0,R1,R2,R3]  (L=left side, R=right side, pin1=L0)
    box(0.55,0.12,0.90, blackMat, x, Y+0.06, z, ry);
    [[-1,0],[1,4]].forEach(([side, nOff]) => {
      for (let i=0;i<4;i++) {
        const pz = z + (-0.30+i*0.20)*Math.cos(ry);
        const px = x + side*Math.cos(ry)*0.30;
        box(0.10,0.035,0.055, pinMat, px, Y+0.018, pz, ry);
        const net = nets && nets[nOff+i];
        if (net) regPad(net, px, pz);
      }
    });
    // pin-1 dot
    const dot = new THREE.Mesh(new THREE.CircleGeometry(0.03,10),
      new THREE.MeshStandardMaterial({color:0x444444,roughness:1}));
    dot.rotation.x=-Math.PI/2;
    dot.position.set(x-0.18*Math.cos(ry), Y+0.062, z-0.30*Math.cos(ry));
    group.add(dot);
  }

  // SOT-23: 3 pins on one side
  function sot23(x, z, ry, nets) {
    box(0.16,0.085,0.22, blackMat, x, Y+0.043, z, ry);
    [-0.08,0,0.08].forEach((dz,i) => {
      const px = x - Math.cos(ry)*0.11;
      const pz = z + dz*Math.cos(ry);
      box(0.06,0.03,0.04, pinMat, px, Y+0.015, pz, ry);
      if (nets && nets[i]) regPad(nets[i], px, pz);
    });
  }

  // Diode SOD-123
  function diode(x, z, ry, netA, netK) {
    box(0.24,0.075,0.14, blackMat, x, Y+0.038, z, ry);
    const band = new THREE.Mesh(new THREE.BoxGeometry(0.03,0.076,0.14),
      new THREE.MeshStandardMaterial({color:0x555555,roughness:0.7}));
    band.position.set(x+Math.cos(ry)*0.10, Y+0.038, z-Math.sin(ry)*0.10);
    band.rotation.y=ry; group.add(band);
    const ax=x-Math.cos(ry)*0.12, az=z+Math.sin(ry)*0.12;
    const kx=x+Math.cos(ry)*0.12, kz=z-Math.sin(ry)*0.12;
    if(netA) regPad(netA,ax,az);
    if(netK) regPad(netK,kx,kz);
  }

  // Inductor (shielded power inductor)
  function inductor(x, z, net1, net2) {
    box(0.26,0.10,0.22, new THREE.MeshStandardMaterial({color:0x2d2010,roughness:0.7}), x, Y+0.05, z);
    const wireMat = new THREE.MeshStandardMaterial({color:0xcc9933,roughness:0.3,metalness:0.9});
    for(let i=0;i<4;i++){
      const w=new THREE.Mesh(new THREE.TorusGeometry(0.08,0.012,6,12),wireMat);
      w.position.set(x-0.09+i*0.06,Y+0.05,z); w.rotation.y=Math.PI/2; group.add(w);
    }
    if(net1) regPad(net1, x-0.13, z);
    if(net2) regPad(net2, x+0.13, z);
  }

  // Crystal
  function crystal(x, z, net1, net2) {
    box(0.22,0.075,0.44, new THREE.MeshStandardMaterial({color:0xc8c8b0,roughness:0.28,metalness:0.78}), x, Y+0.038, z);
    box(0.10,0.04,0.055, pinMat, x, Y+0.02, z-0.22);
    box(0.10,0.04,0.055, pinMat, x, Y+0.02, z+0.22);
    if(net1) regPad(net1, x, z-0.22);
    if(net2) regPad(net2, x, z+0.22);
  }

  // USB-C receptacle â€” 2 main pads
  function usbC(x, z, net1, net2) {
    const shMat = new THREE.MeshStandardMaterial({color:0xc0c0c0,roughness:0.3,metalness:0.9});
    box(0.50,0.18,0.30, shMat, x, Y+0.09, z);
    const slot=new THREE.Mesh(new THREE.BoxGeometry(0.32,0.12,0.01),
      new THREE.MeshStandardMaterial({color:0x111111,roughness:1}));
    slot.position.set(x,Y+0.09,z-0.155); group.add(slot);
    box(0.06,0.05,0.12, pinMat, x-0.18, Y+0.025, z);
    box(0.06,0.05,0.12, pinMat, x+0.18, Y+0.025, z);
    if(net1) regPad(net1, x-0.18, z);
    if(net2) regPad(net2, x+0.18, z);
  }

  // JST 2-pin
  function jst2(x, z, ry, net1, net2) {
    box(0.38,0.22,0.24, new THREE.MeshStandardMaterial({color:0xfafafa,roughness:0.7}), x, Y+0.11, z, ry);
    const p1x=x-Math.cos(ry)*0.09, p1z=z+Math.sin(ry)*0.09;
    const p2x=x+Math.cos(ry)*0.09, p2z=z-Math.sin(ry)*0.09;
    box(0.06,0.16,0.06, pinMat, p1x, Y+0.08, p1z);
    box(0.06,0.16,0.06, pinMat, p2x, Y+0.08, p2z);
    if(net1) regPad(net1, p1x, p1z);
    if(net2) regPad(net2, p2x, p2z);
  }

  // Screw terminal 2-pin
  function screwTerm(x, z, ry, net1, net2) {
    const mat=new THREE.MeshStandardMaterial({color:0x226622,roughness:0.65});
    [-0.16,0.16].forEach((d,i) => {
      const bx=x+Math.cos(ry)*d, bz=z-Math.sin(ry)*d;
      box(0.28,0.26,0.30, mat, bx, Y+0.13, bz, ry);
      const sc=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.04,12),
        new THREE.MeshStandardMaterial({color:0xaaaaaa,roughness:0.3,metalness:0.9}));
      sc.position.set(bx,Y+0.27,bz); group.add(sc);
      if(i===0 && net1) regPad(net1, bx, bz);
      if(i===1 && net2) regPad(net2, bx, bz);
    });
  }

  // SMA connector
  function sma(x, z, net) {
    const mat=new THREE.MeshStandardMaterial({color:0xd4af37,roughness:0.2,metalness:0.95});
    const bar=new THREE.Mesh(new THREE.CylinderGeometry(0.14,0.14,0.40,18),mat);
    bar.position.set(x,Y+0.20,z); bar.rotation.z=Math.PI/2; group.add(bar);
    box(0.40,0.06,0.36, mat, x, Y+0.03, z);
    if(net) regPad(net, x-0.20, z);
  }

  // â”€â”€ MCU (LQFP-32 @ center, 8 pins per side) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  box(1.5,0.13,1.5, blackMat, 0, Y+0.065, 0);
  const mcuNets = {
    // right side (x=+0.82), pin z from -0.49 to +0.49
    R:['mN_R0','mN_R1','mN_R2','mN_R3','mN_R4','mN_R5','mN_R6','mN_R7'],
    // left  side (x=-0.82)
    L:['mN_L0','mN_L1','mN_L2','mN_L3','mN_L4','mN_L5','mN_L6','mN_L7'],
    // top side (z=-0.82), pin x from -0.49 to +0.49
    T:['mN_T0','mN_T1','mN_T2','mN_T3','mN_T4','mN_T5','mN_T6','mN_T7'],
    // bottom (z=+0.82)
    B:['mN_B0','mN_B1','mN_B2','mN_B3','mN_B4','mN_B5','mN_B6','mN_B7'],
  };
  (['R','L']).forEach(side => {
    const sx = side==='R' ? 0.82 : -0.82;
    mcuNets[side].forEach((net,i) => {
      const pz = -0.49 + i*0.14;
      box(0.10,0.04,0.055, pinMat, sx, Y+0.02, pz);
      regPad(net, sx, pz);
    });
  });
  (['T','B']).forEach(side => {
    const sz = side==='T' ? -0.82 : 0.82;
    mcuNets[side].forEach((net,i) => {
      const px = -0.49 + i*0.14;
      box(0.055,0.04,0.10, pinMat, px, Y+0.02, sz);
      regPad(net, px, sz);
    });
  });
  const mcuDot=new THREE.Mesh(new THREE.CircleGeometry(0.05,12),
    new THREE.MeshStandardMaterial({color:0x555555,roughness:1}));
  mcuDot.rotation.x=-Math.PI/2; mcuDot.position.set(-0.60,Y+0.066,-0.60); group.add(mcuDot);

  // â”€â”€ ICs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  soic8( 2.0, 2.0, 0,    ['u2L0','u2L1','u2L2','u2L3', 'u2R0','u2R1','u2R2','u2R3']);
  soic8(-3.0, 0.6, 0,    ['u3L0','u3L1','u3L2','u3L3', 'u3R0','u3R1','u3R2','u3R3']);
  soic8(-3.0,-0.8, 0,    ['u4L0','u4L1','u4L2','u4L3', 'u4R0','u4R1','u4R2','u4R3']);
  soic8( 3.4,-0.6, 0,    ['u5L0','u5L1','u5L2','u5L3', 'u5R0','u5R1','u5R2','u5R3']);

  // â”€â”€ Electrolytics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  elecCap( 1.8,-0.4, 0.26,0.12, 0x1a2a6a, 'c1p','c1n');
  elecCap( 1.8, 0.4, 0.26,0.12, 0x1a2a6a, 'c2p','c2n');
  elecCap(-3.8, 2.2, 0.22,0.10, 0x6a1a1a, 'c3p','c3n');
  elecCap( 3.6, 2.0, 0.22,0.10, 0x1a2a6a, 'c4p','c4n');
  elecCap(-1.8, 2.6, 0.20,0.09, 0x1a4a2a, 'c5p','c5n');
  elecCap(-0.8,-2.0, 0.20,0.09, 0x2a1a6a, 'c6p','c6n');

  // â”€â”€ 0402 MLCCs (decoupling caps in groups near ICs) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  c0402(-1.4, 0.6, 0, 'mN_L4','gnd');  c0402(-1.4, 0.8, 0, 'mN_L5','gnd');
  c0402(-1.4, 1.0, 0, 'mN_L6','gnd');  c0402(-1.4, 1.2, 0, 'mN_L7','gnd');
  c0402( 1.4,-0.6, 0, 'mN_R0','gnd');  c0402( 1.4,-0.4, 0, 'mN_R1','gnd');
  c0402(-3.6, 0.2, 0, 'u3L0','gnd');   c0402(-3.6, 0.4, 0, 'u3L1','gnd');
  c0402(-3.6,-1.0, 0, 'u4L0','gnd');   c0402(-3.6,-1.2, 0, 'u4L1','gnd');
  c0402( 3.6,-0.2, 0, 'u5R0','gnd');   c0402( 3.6,-0.4, 0, 'u5R1','gnd');
  c0402( 1.6, 1.6, 0, 'u2L0','gnd');   c0402( 1.6, 1.8, 0, 'u2L1','gnd');
  c0402(-0.4,-2.4, 0, 'mN_T3','gnd');  c0402(-0.2,-2.4, 0, 'mN_T4','gnd');
  c0402(-2.0,-2.4, Math.PI/2, 'u4L2','gnd');
  c0402( 2.6,-1.6, 0, 'u5L2','gnd');

  // â”€â”€ 0402 Resistors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  r0402(-2.2, 0.0, 0, 'mN_L3','u3R2'); r0402(-2.2,-0.2, 0, 'mN_L2','u3R1');
  r0402(-2.2,-0.4, 0, 'mN_L1','u3R0'); r0402(-2.2,-0.6, 0, 'mN_L0','u4R3');
  r0402( 2.8, 0.4, 0, 'mN_R5','u5L3'); r0402( 2.8, 0.2, 0, 'mN_R4','u5L2');
  r0402( 0.6, 2.2, Math.PI/2, 'u2L2','mN_B5'); r0402( 0.8, 2.2, Math.PI/2, 'u2L3','mN_B6');
  r0402(-3.8,-0.2, 0, 'u3L2','c3p');   r0402(-3.8,-0.4, 0, 'u3L3','c3n');
  r0402( 0.4,-2.6, 0, 'mN_T5','c6p');  r0402( 0.6,-2.6, 0, 'mN_T6','c6n');
  r0402(-1.2, 2.8, 0, 'c5p','mN_B2');  r0402(-1.0, 2.8, 0, 'c5n','mN_B3');
  r0402( 3.0, 1.4, Math.PI/2, 'u5R2','u2R2'); r0402( 3.0, 1.2, Math.PI/2, 'u5R3','u2R3');
  r0402( 1.2,-0.8, 0, 'mN_R2','c1n');  r0402( 1.2,-1.0, 0, 'mN_R3','c2n');
  r0402(-2.2, 2.2, Math.PI/2, 'u3R2','c5p'); r0402(-2.2, 2.0, Math.PI/2, 'u3R3','c5n');

  // â”€â”€ Diodes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  diode(-1.4, 1.4, 0,            'mN_B1','u3R1');
  diode( 3.4,-0.8, Math.PI/2,    'u5L1','u4R1');
  diode(-3.2,-1.6, 0,            'u4L2','c6p');
  diode( 1.4, 1.2, 0,            'mN_B4','u2L0');
  diode(-1.0,-1.8, Math.PI/2,    'mN_T0','c6n');
  diode( 2.4, 1.8, 0,            'mN_B7','u2R0');

  // â”€â”€ Inductors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  inductor(-1.0,-0.4, 'mN_L0','mN_L1');
  inductor( 1.4, 1.0, 'mN_R6','u2L0');
  inductor(-2.4,-2.4, 'u4L3','c6p');
  inductor( 2.8, 1.8, 'u5R2','u2R1');

  // â”€â”€ Crystals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  crystal(-0.8, 2.4, 'mN_B0','mN_B1');
  crystal( 2.4, 2.4, 'u2R2','u2R3');

  // â”€â”€ Connectors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  usbC( 0.2,-2.75, 'mN_T2','mN_T3');
  jst2(-3.8,-1.6, 0, 'u4L2','u4L3');
  jst2( 3.6, 1.2, 0, 'u5R2','u5R3');
  jst2(-3.2,-2.6, Math.PI/2, 'u4L0','u4L1');
  screwTerm(-4.2, 0.0, 0, 'u3L0','u3L1');
  screwTerm( 4.0, 2.2, 0, 'u2R2','u2R3');
  sma( 4.35,-1.8, 'u5R0');

  // â”€â”€ SOT-23 transistors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  sot23( 4.0,-0.4, 0, ['u5R0','u5R1','u5R2']);
  sot23( 4.0,-0.8, 0, ['u5R1','u5R2','u5R3']);
  sot23(-3.8, 1.2, Math.PI, ['u3L0','u3L1','u3L2']);
  sot23( 2.0,-2.4, 0, ['mN_T4','mN_T5','mN_T6']);
  sot23(-2.0,-1.8, 0, ['u4L1','u4L2','u4L3']);
  sot23(-0.8, 0.4, Math.PI/2, ['mN_L4','mN_L5','mN_L6']);

  return group;
}

/* =====================================================================
   COPPER TRACES  â€” reads from the shared pads registry
   ===================================================================== */
let allTraceMeshes = [];
const tpTraces = { TP1:[], TP2:[], TP3:[], TP4:[] };

function createTraces() {
  const group = new THREE.Group();
  const yT = BOARD.depth / 2 + 0.003;
  const TW = TRACE_CONFIG.width;
  const TH = TRACE_CONFIG.height;

  const baseMat = new THREE.MeshStandardMaterial({
    color: 0xd4883a, roughness: 0.18, metalness: 0.92,
    emissive: new THREE.Color(0xc06820), emissiveIntensity: 0.12,
  });

  function seg(x1,z1, x2,z2, tpKey) {
    const dx=x2-x1, dz=z2-z1, len=Math.sqrt(dx*dx+dz*dz);
    if(len<0.005) return;
    const mat = baseMat.clone();
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(len,TH,TW), mat);
    mesh.position.set((x1+x2)/2, yT, (z1+z2)/2);
    mesh.rotation.y = -Math.atan2(dz,dx);
    group.add(mesh);
    allTraceMeshes.push(mesh);
    if(tpKey && tpTraces[tpKey]) tpTraces[tpKey].push(mesh);
  }

  function route(x1,z1, x2,z2, tpKey, corner='h') {
    if(Math.abs(x1-x2)<0.005) { seg(x1,z1,x2,z2,tpKey); return; }
    if(Math.abs(z1-z2)<0.005) { seg(x1,z1,x2,z2,tpKey); return; }
    if(corner==='h') { seg(x1,z1,x2,z1,tpKey); seg(x2,z1,x2,z2,tpKey); }
    else             { seg(x1,z1,x1,z2,tpKey); seg(x1,z2,x2,z2,tpKey); }
  }

  // Assign a TP net color based on which area of the board the net lives in.
  // Uses the centroid of all pads on the net.
  function tpKeyForNet(netName, pts) {
    if(netName.startsWith('mN_L') || netName.startsWith('u3') || netName.startsWith('u4')) return 'TP1';
    if(netName.startsWith('mN_R') || netName.startsWith('u2') || netName.startsWith('u5')) return 'TP2';
    if(netName.startsWith('mN_B') || netName==='c5p'||netName==='c5n') return 'TP3';
    if(netName.startsWith('mN_T') || netName==='c6p'||netName==='c6n') return 'TP4';
    // fallback: use centroid position
    const cx = pts.reduce((s,p)=>s+p[0],0)/pts.length;
    const cz = pts.reduce((s,p)=>s+p[1],0)/pts.length;
    if(cx < 0 && cz > 0) return 'TP3';
    if(cx < 0 && cz < 0) return 'TP1';
    if(cx > 0 && cz < 0) return 'TP4';
    return 'TP2';
  }

  // â”€â”€ CORE: daisy-chain every net that has 2+ pads â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Sort pads spatially (nearest-neighbour greedy) so traces don't cross
  // unnecessarily, then route them in order.
  function sortedChain(pts) {
    if(pts.length <= 1) return pts;
    const rem = [...pts];
    const chain = [rem.splice(0,1)[0]];
    while(rem.length) {
      const last = chain[chain.length-1];
      let best=0, bestD=Infinity;
      rem.forEach(([x,z],i)=>{
        const d=(x-last[0])**2+(z-last[1])**2;
        if(d<bestD){bestD=d;best=i;}
      });
      chain.push(rem.splice(best,1)[0]);
    }
    return chain;
  }

  Object.entries(pads).forEach(([net, rawPts]) => {
    if(rawPts.length < 2) return;
    const tpKey = tpKeyForNet(net, rawPts);
    const pts = sortedChain(rawPts);
    for(let i=0; i<pts.length-1; i++) {
      route(pts[i][0],pts[i][1], pts[i+1][0],pts[i+1][1], tpKey, i%2===0?'h':'v');
    }
  });

  // â”€â”€ Single-pad nets (gnd stubs + orphan pads): connect to nearest other pad â”€â”€
  // Collect all pad positions for proximity search
  const allPadFlat = [];
  Object.entries(pads).forEach(([net, pts]) => {
    if(pts.length >= 2) pts.forEach(p => allPadFlat.push({net, p}));
  });

  Object.entries(pads).forEach(([net, rawPts]) => {
    if(rawPts.length !== 1) return;  // only handle isolated pads
    const [x,z] = rawPts[0];
    // find nearest pad from a multi-pad net
    let bestP=null, bestD=Infinity;
    allPadFlat.forEach(({p}) => {
      const d=(p[0]-x)**2+(p[1]-z)**2;
      if(d>0.001 && d<bestD){bestD=d;bestP=p;}
    });
    if(bestP) {
      const tpKey = tpKeyForNet(net, rawPts);
      route(x,z, bestP[0],bestP[1], tpKey, 'h');
    }
  });

  // â”€â”€ Connect each TP pad to its nearest component pad â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  TP_CONFIG.forEach((cfg, ti) => {
    const tpKey = ['TP1','TP2','TP3','TP4'][ti];
    const [tx,tz] = cfg.pos;
    let bestPt=null, bestD=Infinity;
    allPadFlat.forEach(({p}) => {
      const d=(p[0]-tx)**2+(p[1]-tz)**2;
      if(d<bestD){bestD=d;bestPt=p;}
    });
    if(bestPt) route(tx,tz, bestPt[0],bestPt[1], tpKey);
  });

  // â”€â”€ Vias at pad locations for multi-pad nets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Object.entries(pads).forEach(([, pts]) => {
    if(pts.length < 2) return;
    pts.forEach(([x,z]) => {
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.022,0.008,5,14), matVia.clone());
      ring.position.set(x,yT+0.001,z); ring.rotation.x=Math.PI/2; group.add(ring);
      const hole = new THREE.Mesh(new THREE.CircleGeometry(0.010,10),
        new THREE.MeshBasicMaterial({color:0x020806}));
      hole.rotation.x=-Math.PI/2; hole.position.set(x,yT+0.002,z); group.add(hole);
    });
  });

  return group;
}

/* =====================================================================
   SILKSCREEN TEXT (canvas textures)
   ===================================================================== */
function makeTextSprite(text, color = '#e8eedc', size = 128, fontSize = 18) {
  const padding = 8;
  const canvas = document.createElement('canvas');
  canvas.width = size * 3.2;
  canvas.height = size * 0.75;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Subtle dark background halo for legibility against PCB
  ctx.fillStyle = 'rgba(5,15,10,0.55)';
  ctx.roundRect(0, 2, canvas.width, canvas.height - 4, 6);
  ctx.fill();

  ctx.fillStyle = color;
  ctx.font = `bold ${fontSize}px "Share Tech Mono", monospace`;
  ctx.textBaseline = 'middle';
  ctx.shadowColor = color;
  ctx.shadowBlur = 8;
  ctx.fillText(text, padding, canvas.height / 2);

  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent: true,
    depthTest: true,
    opacity: 1.0,
  });
  const sprite = new THREE.Sprite(mat);
  const aspect = canvas.width / canvas.height;
  sprite.scale.set(aspect * 0.42, 0.42, 1);
  return sprite;
}

function addSilkscreenLabels(_group) {
  // Ref designators removed â€” only test point callout labels are shown
}

/* =====================================================================
   TEST POINTS
   ===================================================================== */
function createGlowSprite(color, size = 1.2) {
  const canvas = document.createElement('canvas');
  canvas.width = 128; canvas.height = 128;
  const ctx = canvas.getContext('2d');
  const cx = 64, cy = 64;
  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 60);
  gradient.addColorStop(0,   color + 'ff');
  gradient.addColorStop(0.25, color + 'aa');
  gradient.addColorStop(0.6,  color + '33');
  gradient.addColorStop(1,   color + '00');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 128, 128);

  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({
    map: tex,
    blending: THREE.AdditiveBlending,
    transparent: true,
    depthWrite: false,
    opacity: 0,
  });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(size, size, 1);
  return sprite;
}

function createCalloutLabel(text, cssColor) {
  const cw = 300, ch = 52;
  const canvas = document.createElement('canvas');
  canvas.width = cw; canvas.height = ch;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, cw, ch);

  // Background pill
  ctx.fillStyle = 'rgba(5,10,15,0.93)';
  ctx.strokeStyle = cssColor;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.roundRect(2, 2, cw - 4, ch - 4, 8);
  ctx.fill();
  ctx.stroke();

  // Outer glow
  ctx.strokeStyle = cssColor + '44';
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.roundRect(2, 2, cw - 4, ch - 4, 8);
  ctx.stroke();

  // Left accent bar
  ctx.fillStyle = cssColor;
  ctx.beginPath();
  ctx.roundRect(7, 8, 4, ch - 16, 2);
  ctx.fill();

  // Label text
  ctx.shadowColor = cssColor;
  ctx.shadowBlur = 10;
  ctx.fillStyle = cssColor;
  ctx.font = 'bold 18px "Share Tech Mono", monospace';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, 18, ch / 2);

  // Click hint
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.28)';
  ctx.font = '11px "Share Tech Mono", monospace';
  ctx.textAlign = 'right';
  ctx.fillText('CLICK', cw - 10, ch / 2);

  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, opacity: 0.93 });
  const sprite = new THREE.Sprite(mat);
  const aspect = cw / ch;
  sprite.scale.set(aspect * 0.36, 0.36, 1);
  return sprite;
}

function createTestPoints() {
  const group = new THREE.Group();
  const yTop = BOARD.depth / 2 + 0.001;

  TP_CONFIG.forEach((cfg, idx) => {
    const tpGroup = new THREE.Group();
    const [px, pz] = cfg.pos;

    // â”€â”€ Outer copper annular ring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const outerRingGeo = new THREE.TorusGeometry(0.09, 0.028, 10, 28);
    const outerMat = new THREE.MeshStandardMaterial({
      color: 0xc07a28, roughness: 0.18, metalness: 0.96,
      emissive: new THREE.Color(cfg.color), emissiveIntensity: 0.05,
    });
    const outerRing = new THREE.Mesh(outerRingGeo, outerMat);
    outerRing.rotation.x = Math.PI / 2;
    tpGroup.add(outerRing);

    // â”€â”€ Inner pad â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const padGeo = new THREE.CircleGeometry(0.062, 24);
    const padMat = new THREE.MeshStandardMaterial({
      color: 0xb07030, roughness: 0.15, metalness: 0.97,
      emissive: new THREE.Color(cfg.color), emissiveIntensity: 0.05,
    });
    const pad = new THREE.Mesh(padGeo, padMat);
    pad.rotation.x = -Math.PI / 2;
    pad.position.y = 0.001;
    tpGroup.add(pad);

    // â”€â”€ Center drill â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const centerGeo = new THREE.CircleGeometry(0.018, 16);
    const centerMat = new THREE.MeshStandardMaterial({ color: 0x040c0a, roughness: 1 });
    const center = new THREE.Mesh(centerGeo, centerMat);
    center.rotation.x = -Math.PI / 2;
    center.position.y = 0.003;
    tpGroup.add(center);

    // â”€â”€ Glow halo sprite â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const glow = createGlowSprite(cfg.cssColor, 1.0);
    glow.position.y = 0.04;
    tpGroup.add(glow);

    // â”€â”€ Point light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const ptLight = new THREE.PointLight(cfg.color, 0.08, 3);
    ptLight.position.y = 0.12;
    tpGroup.add(ptLight);

    // â”€â”€ Stem pole (thin cylinder from pad up to label) â”€â”€â”€â”€â”€â”€â”€â”€
    const stemH = 0.9;
    const stemGeo = new THREE.CylinderGeometry(0.005, 0.005, stemH, 5);
    const stemMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color(cfg.color), roughness: 0.4, metalness: 0.3,
      emissive: new THREE.Color(cfg.color), emissiveIntensity: 0.4,
      transparent: true, opacity: 0.6,
    });
    const stem = new THREE.Mesh(stemGeo, stemMat);
    stem.position.y = stemH / 2 + 0.04;
    tpGroup.add(stem);

    // â”€â”€ Floating callout label â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const label = createCalloutLabel(cfg.label, cfg.cssColor);
    label.position.set(0.45, stemH + 0.12, 0);
    tpGroup.add(label);

    tpGroup.position.set(px, yTop, pz);
    group.add(tpGroup);

    // â”€â”€ Invisible picker mesh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const pickerGeo = new THREE.CircleGeometry(0.18, 14);
    const pickerMat = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });
    const picker = new THREE.Mesh(pickerGeo, pickerMat);
    picker.rotation.x = -Math.PI / 2;
    picker.position.set(px, yTop + 0.01, pz);
    picker.userData.tpIndex = idx;
    group.add(picker);

    testPointMeshes.push({
      group: tpGroup, picker,
      outerMat, padMat,
      glow, ptLight, stem, stemMat, label,
      config: cfg,
      traceMeshes: tpTraces[cfg.id],
      glowT: 0, _targetGlow: 0,
    });
  });

  return group;
}

/* =====================================================================
   SCENE ASSEMBLY
   ===================================================================== */
function buildScene() {
  // Board
  const boardGroup = createBoard();
  scene.add(boardGroup);

  // Components FIRST â€” populates the shared pads{} registry
  const compGroup = createComponents();
  scene.add(compGroup);

  // Traces SECOND â€” reads pads{} to connect components
  const traceGroup = createTraces();
  scene.add(traceGroup);

  // Silkscreen
  addSilkscreenLabels(scene);

  // Test points
  const tpGroup = createTestPoints();
  scene.add(tpGroup);

  // Ground plane for shadows
  const groundGeo = new THREE.PlaneGeometry(30, 30);
  const groundMat = new THREE.ShadowMaterial({ opacity: 0.35 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.5;
  ground.receiveShadow = true;
  scene.add(ground);
}

/* =====================================================================
   INTERACTION â€” HOVER & CLICK
   ===================================================================== */
const tooltip = document.getElementById('tooltip');
const tooltipLabel = document.getElementById('tooltip-label');

function updateTooltip(visible, label, x, y, cssColor) {
  if (visible) {
    tooltipLabel.textContent = label;
    tooltipLabel.style.color = cssColor;
    tooltip.style.borderColor = cssColor + '66';
    tooltip.style.left = (x + 18) + 'px';
    tooltip.style.top  = (y - 30) + 'px';
    tooltip.classList.add('visible');
  } else {
    tooltip.classList.remove('visible');
  }
}

let mouseX = 0, mouseY = 0;
window.addEventListener('mousemove', e => {
  mouse.x = (e.clientX / window.innerWidth)  *  2 - 1;
  mouse.y = (e.clientY / window.innerHeight) * -2 + 1;
  mouseX = e.clientX; mouseY = e.clientY;
});

window.addEventListener('click', () => {
  if (hoveredTP !== null) {
    openModal(hoveredTP);
  }
});

// ESC to close
window.addEventListener('keydown', e => {
  if (e.key === 'Escape') closeModal();
});

function performRaycast() {
  if (!raycaster || testPointMeshes.length === 0) return;
  raycaster.setFromCamera(mouse, camera);
  const pickers = testPointMeshes.map(tp => tp.picker);
  const hits = raycaster.intersectObjects(pickers);

  const prevHovered = hoveredTP;
  hoveredTP = hits.length > 0 ? hits[0].object.userData.tpIndex : null;

  // Update hover states
  testPointMeshes.forEach((tp, i) => {
    const isHovered = (i === hoveredTP);
    tp._targetGlow = isHovered ? 1.0 : 0.0;
  });

  if (hoveredTP !== null) {
    const cfg = testPointMeshes[hoveredTP].config;
    // CUSTOMIZE: TP labels in tooltip â€” see TP_CONFIG at top
    const sectionNames = { about: 'ABOUT ME', projects: 'PROJECTS', experience: 'EXPERIENCE', collabs: 'COLLABORATIONS' };
    updateTooltip(true, sectionNames[cfg.section] || cfg.id, mouseX, mouseY, cfg.cssColor);
    document.body.style.cursor = 'pointer';
  } else {
    updateTooltip(false);
    document.body.style.cursor = 'default';
  }
}

/* =====================================================================
   MODAL CONTENT
   CUSTOMIZE: Replace placeholder text with your real content
   ===================================================================== */
const MODAL_CONTENT = {
  about: {
    badge: 'TP1 Â· NODE_ABOUT',
    title: 'About Me',
    html: `
      <div class="section-label">OVERVIEW</div>
      <!-- CUSTOMIZE: Your bio -->
      <p class="bio-text">
        Hardware engineer with 2+ years designing high-rel PCBs for aerospace applications.
        I specialize in multi-layer stack-ups, signal integrity, and bringing embedded systems from napkin sketch to production.
      </p>
      <p class="bio-text">
        Currently open to contract and full-time opportunities in hardware design, firmware architecture, and product development.
        I care deeply about manufacturable designs and clean, well-documented schematics.
      </p>
      <div class="section-label">TOOLS & SKILLS</div>
      <!-- CUSTOMIZE: Your skill tags -->
      <div class="skill-grid">
        <div class="skill-tag">Altium Designer</div>
        <div class="skill-tag">KiCad 8</div>
        <div class="skill-tag">LTspice</div>
        <div class="skill-tag">C / C++</div>
        <div class="skill-tag">Python</div>
        <div class="skill-tag">SPI / I2C / UART</div>
        <div class="skill-tag">RF & EMC</div>
        <div class="skill-tag">FPGA (VHDL)</div>
        <div class="skill-tag">USB 3.x</div>
        <div class="skill-tag">DDR4 Layout</div>
        <div class="skill-tag">DFM / DFA</div>
      </div>
      <div class="section-label">EDUCATION</div>
      <p class="bio-text">M.S. Electronics Engineering â€” Politecnico di Milano, 2026</p>
      <p class="bio-text">B.E. Electronics Engineering â€” Thapar University, 2022</p>
    `,
  },
  projects: {
    badge: 'TP2 Â· NODE_PROJECTS',
    title: 'Projects',
    html: `
      <div class="section-label">SELECTED WORK</div>
      <!-- CUSTOMIZE: Your project cards -->
      <div class="card-grid">
        <div class="project-card">
          <div class="project-card-tag">HARDWARE</div>
          <div class="project-card-title">Lunar Rover Power Distribution Unit</div>
          <div class="project-card-desc">Designed a 8-layer PCB for radiation-tolerant power distribution system for the lunar garage control of upcoming Artemis Lunar Rovers.</div>
        </div>
        <div class="project-card">
          <div class="project-card-tag">HARDWARE</div>
          <div class="project-card-title">Smart Passive Fault-Tolerant Wrapper</div>
          <div class="project-card-desc">Designed and validated a passive analog fault-tolerant wrapper to detect fault-induced anomalies of mixed-signal stepper motor drivers.</div>
        </div>
        <div class="project-card">
          <div class="project-card-tag">FIRMWARE</div>
          <div class="project-card-title">Edge AI Accelerator for Debris Detection</div>
          <div class="project-card-desc">Implemented an FPGA-based hardware accelerator for edge AI inference, enabling low-latency detection of debris from static images using a CNN model.</div>
        </div>
        <div class="project-card">
          <div class="project-card-tag">OPEN SOURCE</div>
          <div class="project-card-title">RISC-V Core Design</div>
          <div class="project-card-desc">Demonstrated a complete RTL-to-GDSII implementation flow using the open-source OpenLANE framework.</div>
        </div>
      </div>
    `,
  },
  experience: {
    badge: 'TP3 Â· NODE_EXPERIENCE',
    title: 'Experience',
    html: `
      <div class="section-label">WORK HISTORY</div>
      <!-- CUSTOMIZE: Your experience timeline -->
      <div class="timeline">
        <div class="timeline-item">
          <div class="timeline-date">2025 â€” NOW</div>
          <div>
            <div class="timeline-role">Hardware Engineer</div>
            <div class="timeline-company">Lunar Outpost EU</div>
            <div class="timeline-desc">Co-Lead hardware architect for lunar garage power distribution and sensor acquistion platform. Owned full board design lifecycle: schematic, layout, bring-up, and production handoff. Reduced BOM cost by 18% through component consolidation.</div>
          </div>
        </div>
        <div class="timeline-item">
          <div class="timeline-date">2025 â€” 2025</div>
          <div>
            <div class="timeline-role">Hardware Engineer Intern</div>
            <div class="timeline-company">Revolv Space BV</div>
            <div class="timeline-desc">Designed radiation-tolerant avionics boards for CubeSat IOD missions. Passed ECSS and NASA-STD-8739 compliance testing. Wrote embedded C firmware for fault injection and validation.</div>
          </div>
        </div>
        <div class="timeline-item">
          <div class="timeline-date">2023 â€” 2025</div>
          <div>
            <div class="timeline-role">Avionics Systems Engineer</div>
            <div class="timeline-company">Capsule Corporation SrL (STARTUP)</div>
            <div class="timeline-desc">First hardware hire at a space propulsion startup. Built manufacturing relationships in China, iterated through 4 hardware revisions in 12 months to reach TRL readiness.</div>
          </div>
        </div>
        <div class="timeline-item">
          <div class="timeline-date">2022 â€” 2022</div>
          <div>
            <div class="timeline-role">R&D Intern</div>
            <div class="timeline-company">STmicroelectronics</div>
            <div class="timeline-desc">Performed RTL design and functional verification of digital control blocks for STM32 microcontrollers, Developed Python-based automation tools.</div>
          </div>
        </div>
      </div>
      <div class="section-label">CERTIFICATIONS</div>
      <p class="bio-text">IPC-7711/7721 Certified</p>
    `,
  },
  collabs: {
    badge: 'TP4 Â· NODE_COLLABS',
    title: 'Collaborations',
    html: `
      <div class="section-label">COLLABORATIONS GROUPS</div>

      <div class="group-card">
        <div class="group-card-name">SGAC Small Satellites Project Group</div>
        <div class="group-card-role">RESEARCHER Â· 2023 â€“ PRESENT</div>
        <div class="group-card-desc">Research and author technical papers on avionics and space systems. Collaborated with international teams to publish findings in peer-reviewed journals and conferences.</div>
      </div>

      <div class="group-card">
        <div class="group-card-name">PoliSpace</div>
        <div class="group-card-role">AVIONICS SUBSYSTEM MEMBER Â· 2023 â€“ 2024</div>
        <div class="group-card-desc">Designed sensor acquisition PCBs and wrote sensor fusion firmware for a student-built 6U CubeSat. Collaborated under ESA Fly Your Satellite program, achieving success targets within 3%.</div>
      </div>

      <div class="group-card">
        <div class="group-card-name">Endurosat Summer School</div>
        <div class="group-card-role">SPACE CADET Â· 2023 â€“ 2023</div>
        <div class="group-card-desc">Weekly build sessions focused on developing on commercial CubeSAT hardware. Contributed to schematic capture and developing firmware for onboard systems.</div>
      </div>

      <div class="group-card">
        <div class="group-card-name">Formula Student</div>
        <div class="group-card-role">POWER ELECTRONICS DESIGNER Â· 2020 â€“ 2022</div>
        <div class="group-card-desc">Designed the battery management system PCB for the team's electric vehicle. Handled cell balancing, thermal monitoring, and CAN bus integration.</div>
      </div>

      <div class="section-label">LOOKING TO COLLABORATE ON</div>
      <div class="skill-grid">
        <div class="skill-tag">Aerospace &amp; Defence</div>
        <div class="skill-tag">FPGA Development</div>
        <div class="skill-tag">Medical Devices</div>
        <div class="skill-tag">Open Source HW</div>
        <div class="skill-tag">Hackathons</div>
      </div>

      <div class="section-label">CONTACT</div>
      <div class="contact-icons">
        <a class="contact-link" href="mailto:paul.abhronil@gmail.com" target="_blank">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>
          paul.abhronil@gmail.com
        </a>
        <a class="contact-link" href="https://github.com/PaulZeroOne" target="_blank">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.477 2 2 6.477 2 12c0 4.418 2.865 8.166 6.839 9.489.5.092.682-.217.682-.482 0-.237-.009-.868-.013-1.703-2.782.604-3.369-1.34-3.369-1.34-.454-1.155-1.11-1.463-1.11-1.463-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836a9.59 9.59 0 012.504.337c1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.163 22 16.418 22 12c0-5.523-4.477-10-10-10z"/></svg>
          PaulZeroOne
        </a>
        <a class="contact-link" href="https://linkedin.com/in/abhronilpaul0" target="_blank">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
          abhronilpaul0
        </a>
      </div>
    `,
  },
};

/* =====================================================================
   MODAL LOGIC
   ===================================================================== */
const overlay = document.getElementById('modal-overlay');
const modalBody = document.getElementById('modal-body');
const modalBadge = document.getElementById('modal-tp-badge');
const modalTitle = document.getElementById('modal-title');
const modalEl = document.getElementById('modal');

document.getElementById('modal-close').addEventListener('click', closeModal);
overlay.addEventListener('click', e => { if (e.target === overlay) closeModal(); });

function openModal(tpIndex) {
  const cfg = testPointMeshes[tpIndex].config;
  const content = MODAL_CONTENT[cfg.section];
  if (!content) return;

  modalBadge.textContent = content.badge;
  modalBadge.style.color = cfg.cssColor;
  modalBadge.style.textShadow = `0 0 8px ${cfg.cssColor}`;
  modalTitle.textContent = content.title;
  modalBody.innerHTML = content.html;
  modalEl.style.setProperty('--modal-accent', cfg.cssColor);
  document.querySelectorAll('.project-card-tag, .timeline-company').forEach(el => {
    el.style.color = cfg.cssColor;
  });
  document.querySelectorAll('.collab-avatar').forEach(el => {
    el.style.color = cfg.cssColor;
    el.style.border = `1px solid ${cfg.cssColor}44`;
  });

  overlay.classList.add('open');
}

function closeModal() {
  overlay.classList.remove('open');
}

/* =====================================================================
   ANIMATION LOOP
   ===================================================================== */
// Trace pulse animation state
let pulseT = 0;

function animate() {
  animFrameId = requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  pulseT += dt;

  controls.update();

  // Idle rotation
  if (idleRotating && !overlay.classList.contains('open')) {
    const target = testPointMeshes[0]?.group.parent;
    scene.rotation.y += dt * 0.06;
  }

  // Raycast for hover
  performRaycast();

  // Animate test points + traces
  const anyHovered = hoveredTP !== null;
  const hoveredColor = anyHovered ? new THREE.Color(testPointMeshes[hoveredTP].config.color) : null;

  testPointMeshes.forEach((tp, i) => {
    // Smooth glow transition
    tp.glowT += (tp._targetGlow - tp.glowT) * (1 - Math.exp(-10 * dt));

    const g = tp.glowT;
    const breathe = 0.08 + Math.sin(pulseT * 2.4 + i * 1.3) * 0.04;

    tp.outerMat.emissiveIntensity = breathe + g * 1.0;
    tp.padMat.emissiveIntensity   = breathe + g * 1.1;
    tp.glow.material.opacity      = 0.10 + g * 0.65;
    tp.ptLight.intensity          = 0.1 + g * 3.5;

    // Stem pulses with glow
    if (tp.stemMat) {
      tp.stemMat.emissiveIntensity = 0.25 + g * 0.6;
      tp.stemMat.opacity = 0.5 + g * 0.45;
    }

    // Label brightens on hover
    if (tp.label) {
      tp.label.material.opacity = 0.88 + g * 0.12;
    }
  });

  // â”€â”€ ALL TRACES glow when any TP is hovered â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  allTraceMeshes.forEach((mesh, ti) => {
    if (anyHovered) {
      // Full board glow in hovered TP's color with travelling pulse
      const speed = 1.8;
      const phase = (pulseT * speed - ti * 0.09) % 2.8;
      const pulseVal = (phase > 0 && phase < 1) ? Math.sin(phase * Math.PI) : 0;
      mesh.material.emissive.copy(hoveredColor);
      mesh.material.emissiveIntensity = 0.45 + 0.4 * pulseVal;
    } else {
      // Idle: warm copper breath
      mesh.material.emissive.set(0xc06820);
      mesh.material.emissiveIntensity = 0.10 + Math.sin(pulseT * 0.8 + ti * 0.3) * 0.05;
    }
  });

  renderer.render(scene, camera);
}

/* =====================================================================
   RESIZE HANDLER
   ===================================================================== */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* =====================================================================
   INIT
   ===================================================================== */
function init() {
  initScene();
  initLighting();
  initMaterials();
  buildScene();

  // Start idle rotation after short delay
  setTimeout(() => { idleRotating = true; }, 1500);

  animate();

  // Hide loading screen
  setTimeout(() => {
    document.getElementById('loading').classList.add('hidden');
    setTimeout(() => {
      document.getElementById('loading').style.display = 'none';
    }, 700);
  }, 600);
}

init();
</script>
</body>
</html>
